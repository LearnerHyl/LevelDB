# LevelDB

LevelDB结构简单,不依赖于任何第三方库,具有很好的独立,虽然其有针对性的对BigTable做了一定程度的简化,然而BigTable的主要技术思想与数据结构都体现在了LevelDB中。因此,LevelDB可以看作是BigTable的简化版或单机版。

通过阅读LevelDB源码，加深对LevelDB的理解，相关注释都加到了源码上。下面是阅读的目录，方便后续复习。

# 基本数据结构

## Slice

重点了解为什么使用Slice而不使用String。

## Comparator

Comparator本身是一个纯虚类（类似于Go中的Interface），可以以子类BytewiseComparatorImpl和InternalKeyComparator为例进行开始阅读，其中AdvanceFucntions部分可能刚开始不知道是做什么用的，后面读到LevelDB的一些功能后，就知道其适用场景了。

## Iterator

LevelDB的Iterator十分强大，同样Iterator本身是一个纯虚类，唯一的非虚函数是CleanUp函数，用于回收迭代器的资源，由Iterator的析构函数调用相关cleanup函数实现资源的释放与清除。

## 系统参数

详情请见头文件options.h中的内容。里面介绍了一些数据压缩方式，以及在使用DB::Open启动数据库实例时可以指定的一些参数。具体分为如下几类参数：

- 影响DB行为的参数。
- 影响DB性能的参数。

这里有一个和DB::Write操作相关的sync参数需要提一下，sync\==false的DB写操作具有与“write()”系统调用相似的崩溃语义。sync==true的DB写操作具有与“write()”系统调用后的“fsync()”相似的崩溃语义。

传统的UNIX实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲进行。当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式被称为延迟写（delayed write）（Bach [1986]第3章详细讨论了缓冲区高速缓存）。

延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，使得欲写到文件中的数据在一段时间内并没有写到磁盘上。当系统发生故障时，这种延迟可能造成文件更新内容的丢失。为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync和fdatasync三个函数。

sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。
通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。

fsync函数只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。
fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。

对于提供事务支持的数据库，在事务提交时，都要确保事务日志（包含该事务所有的修改操作以及一个提交记录）完全写到硬盘上，才认定事务提交成功并返回给应用层。

# LevelDB使用入门
